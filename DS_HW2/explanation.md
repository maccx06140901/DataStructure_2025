# Problem C和Shunting-yard
---

## 🧩 一、為什麼要轉成前序？

在中序表示式中（例如 `3 + 4 * 2`），  
我們需要同時考慮 **運算子優先權** 以及 **括號**。  
也就是說：
- `*` 和 `/` 的優先權比 `+` 和 `-` 高；
- 括號又可能改變原本的順序。

這使得「邊讀邊算」的過程很複雜。

而前序 (Prefix) 的特點是：
- 運算子永遠在它的兩個運算元前面；
- 優先權與括號的資訊已經被轉換過程決定；
- 所以在求值階段只需 **一個堆疊 (stack)** 就能完成計算。

> 💡 簡單說：  
> **把「誰先算」的邏輯提前處理好，計算就變成純機械操作。**

---

## ⚙️ 二、演算法流程（Shunting-yard 建樹法）

我最搞不懂的地方就是演算法的部分。
一開始不知道為什麼中序變前序就可以方便計算，
後來又在思考為什麼如果op_top的運算子優先級相等或更高就要先pop出來。
總而言之這兩個問題應該是我寫這個題目的時候跟ChatGPT討論最久的地方。

### 解題步驟
1. **準備兩個堆疊：**
   - `op_stack`：存放運算子；
   - `node_stack`：存放節點（數字或子樹）。

2. **從左到右掃描 token：**
   - 若為數字：建立葉節點推入 `node_stack`
   - 若為 `(`：推入 `op_stack`
   - 若為 `)`：  
     - 不斷彈出 `op_stack` 直到遇到 `(`  
     - 每次彈出運算子時，從 `node_stack` 取兩棵子樹建立新節點再推回。
   - 若為運算子：
     - 只要堆頂的運算子優先權高於或等於目前的運算子，  
       就先處理堆頂（建立節點）；
     - 然後再把目前運算子推入 `op_stack`。

3. **處理剩餘堆疊：**
   - 當輸入讀完後，把 `op_stack` 中剩餘運算子依序彈出並建樹。

4. **最後 `node_stack` 只剩一棵樹，就是完整的運算樹。**

### 範例: 3 - 4 / (1 - 5)
| Token | 動作 | op_stack (底→頂) | val_stack (左→右) | 說明 |
|-------|-------|------------------|-------------------|------|
| `3` | push 數字 |  | [3] | 數字直接進值堆疊 |
| `-` | push 運算子 | [-] | [3] | 空堆疊，直接放入 |
| `4` | push 數字 | [-] | [3,4] |  |
| `/` | 比較 `/` vs `-` → `/` 優先級高，直接放入 | [-, /] | [3,4] | `/` 應該後算，但比 `-` 優先 |
| `(` | push 括號 | [-, /, (] | [3,4] | 左括號當牆，隔開外層 |
| `1` | push 數字 | [-, /, (] | [3,4,1] |  |
| `-` | push 運算子 | [-, /, (, -] | [3,4,1] | 括號內新的 `-` |
| `5` | push 數字 | [-, /, (, -] | [3,4,1,5] |  |
| `)` | 遇右括號 → 清括號內 | [-, /] | [3,4, Node(-,1,5)] | `(1-5)` 子樹完成 |
| 結束 | 清堆疊 | [] | [ Node(-,3, Node(/,4,Node(-,1,5))) ] | 完成整棵樹 |

### 什麼是 Shunting-yard?
Shunting-yard 是一個把 **中序式 (Infix)** 轉成 **可直接計算的序列（前序/後序）或運算樹** 的方法。
它用兩個堆疊（或一堆疊 + 輸出佇列）把「優先權、結合性、括號」這些語法規則**先解析好**，讓後續計算可以純機械化。
### 問題一: 為什麼中序變前序就可以方便計算?
中序表示式（例如 `3 + 4 * 2`）是**給人看的**，  
但電腦在讀的時候會困惑：「要先算哪個？」  
它需要去解析：
- 哪個運算子優先？
- 哪裡有括號？
- 哪個運算子屬於哪個運算元？

因此中序式要先經過「語法分析」才能執行。

而前序（Prefix）則已經**把運算順序直接寫在順序中**。  例如：
中序：`` 3 + 4 * 2 ``
前序：`` + 3 * 4 2 ``
### 問題二: 為什麼如果op_top的運算子優先級相等或更高就要先pop出來?
op_top的運算子如果優先級更高或是相等的時候要先pop出來，
這裡我寫了一個priotiry()的function來快速取得優先級:
```c
int priority(char operator){
  if(operator == '*' || operator == '/') return 2;
  if(operator == '+' || operator == '-') return 1;
  else return 0;
}
```
所以為甚麼如果op_top的運算子如果優先級較高，就要先pop出來呢?
這是因為我們在掃描算式時是從左到右的，
如果op_stack裡面的運算子，或者說已經被讀過的運算子，
它的優先級比較高或是和現在掃描到的運算子相等，
那先被讀到的本來就應該比後被讀到的還要早算。
這樣一來，不僅確保了先後順序，也讓op_stack裡面不會有運算子的priority比較高卻一直被卡在裡面的情況發生。


---

## 🧮 三、運算樹求值

採用遞迴求值：
```c
int cal(Node* root){
    if(root == NULL) return 0;
    if(root->is_num == 1) return root->num;
    int leftSub = cal(root->left);
    int rightSub = cal(root->right);
    if(root->left != NULL && root->right != NULL){
        if(root->ch == '+') return leftSub + rightSub;
        if(root->ch == '-') return leftSub - rightSub;
        if(root->ch == '*') return leftSub * rightSub;
        if(root->ch == '/') return leftSub / rightSub;
    }
}
```

## 四、總結

幾乎都弄懂之後我才發現 : **只要把表達式變成運算樹，然後從葉節點（leaf）往上逐步合併，就一定能得到正確結果。**
### 為什麼可行
- 中序式轉成「**運算樹**」後，每個**內部節點**都是一個「運算子」，它的**左右子樹**就是它的兩個運算元。
- 只要**左右子樹都已經有值**，這個節點就能被**合併**成一個值。
- 從**葉子**（純數字）開始，一層一層往上合併，最後樹根就是整個表達式的值。
- 這其實等價於「**後序走訪 Postorder**」或「**前序（右→左）堆疊計算**」，只是用樹的觀點更直觀。
### 範例：`3 - 4 / ( 1 - 5 )`

#### 運算樹（Expression Tree）

```markdown
    -
   / \
  3   /
     / \
    4   -
       / \
      1   5
```
#### 自底向上（leaf → root）計算步驟
1. `(1 - 5) = -4`
2. `(4 / -4) = -1`
3. `(3 - (-1)) = 4`

**最終結果：`4`**
